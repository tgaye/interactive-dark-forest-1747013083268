<!DOCTYPE html>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Dark Forest</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #020202;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
       
  frameRate(60); }
        #canvas-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            position: relative;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.8.0/lib/p5.js"></script>

<base target="_self">


  <button id="fs-toggle">
    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
      <path d="M1.5 1H6v1.5H3v3H1.5V1zM10 1h4.5v4.5H13v-3h-3V1zM1.5 10.5H3v3h3V15H1.5v-4.5zM13 13.5v-3h1.5V15H10v-1.5h3z"></path>
    </svg>
  </button>
    <div id="canvas-container"></div>

    <script>
        const sketch = function(p) {
            // Forest parameters
            let trees = [];
            let fireflies = [];
            const maxFireflies = 150;
            let fogDensity = 0.3;
            let mouseInfluence = 0;
            let lastMouseX = 0;
            let lastMouseY = 0;
            let mouseVelocity = p.createVector(0, 0);
            let bgGradient;
            let moon;
            
            p.setup = function() {
                let canvas = p.createCanvas(p.min(p.windowWidth, 1200), p.windowHeight);
                canvas.parent('canvas-container');
                p.colorMode(p.HSB, 360, 100, 100, 1);
                
                // Create background gradient
                bgGradient = p.createGraphics(p.width, p.height);
                for (let y = 0; y < p.height; y++) {
                    let inter = p.map(y, 0, p.height, 0, 1);
                    let c = p.lerpColor(p.color(210, 80, 10), p.color(220, 90, 5), inter);
                    bgGradient.stroke(c);
                    bgGradient.line(0, y, p.width, y);
                }
                
                // Create moon
                moon = {
                    x: p.width * 0.8,
                    y: p.height * 0.2,
                    size: p.width * 0.1,
                    glow: p.createGraphics(p.width, p.height)
                };
                
                // Draw moon glow
                moon.glow.ellipseMode(p.CENTER);
                for (let r = moon.size; r < moon.size * 3; r += 2) {
                    let alpha = p.map(r, moon.size, moon.size * 3, 0.3, 0);
                    moon.glow.fill(50, 10, 100, alpha);
                    moon.glow.noStroke();
                    moon.glow.ellipse(moon.x, moon.y, r, r);
                }
                
                // Create trees
                for (let i = 0; i < 30; i++) {
                    trees.push(new Tree());
                }
                
                // Create fireflies
                for (let i = 0; i < maxFireflies / 2; i++) {
                    fireflies.push(new Firefly());
                }
            };
            
            p.draw = function() {
                // Update mouse velocity
                mouseVelocity.x = p.mouseX - lastMouseX;
                mouseVelocity.y = p.mouseY - lastMouseY;
                lastMouseX = p.mouseX;
                lastMouseY = p.mouseY;
                
                // Calculate mouse influence (how much the mouse is moving)
                mouseInfluence = p.constrain(p.map(mouseVelocity.mag(), 0, 20, 0, 1), 0, 1);
                
                // Draw background
                p.image(bgGradient, 0, 0);
                
                // Draw moon glow
                p.image(moon.glow, 0, 0);
                
                // Draw moon
                p.fill(50, 10, 100);
                p.noStroke();
                p.ellipse(moon.x, moon.y, moon.size, moon.size);
                
                // Draw fog
                drawFog();
                
                // Update and draw trees
                for (let tree of trees) {
                    tree.update();
                    tree.display();
                }
                
                // Update and draw fireflies
                for (let firefly of fireflies) {
                    firefly.update();
                    firefly.display();
                }
                
                // Add more fireflies if mouse is moving and we're below max
                if (mouseInfluence > 0.3 && fireflies.length < maxFireflies) {
                    fireflies.push(new Firefly());
                }
                
                // Remove fireflies if we're above max
                while (fireflies.length > maxFireflies) {
                    fireflies.shift();
                }
            };
            
            function drawFog() {
                p.push();
                p.blendMode(p.SOFT_LIGHT);
                for (let i = 0; i < 5; i++) {
                    let alpha = fogDensity * 0.1;
                    p.fill(220, 30, 30, alpha);
                    p.noStroke();
                    p.rect(0, 0, p.width, p.height);
                }
                p.pop();
            }
            
            class Tree {
                constructor() {
                    this.x = p.random(p.width);
                    this.y = p.height;
                    this.width = p.random(10, 30);
                    this.height = p.random(p.height * 0.3, p.height * 0.7);
                    this.branches = [];
                    this.hue = p.random(100, 140);
                    this.saturation = p.random(30, 50);
                    this.brightness = p.random(10, 20);
                    
                    // Create branches
                    for (let i = 0; i < 5; i++) {
                        this.branches.push({
                            angle: p.random(-p.PI/4, p.PI/4),
                            length: p.random(this.height * 0.3, this.height * 0.5),
                            width: p.random(this.width * 0.3, this.width * 0.7)
                        });
                    }
                }
                
                update() {
                    // Slight sway in the wind
                    for (let branch of this.branches) {
                        branch.angle += p.sin(p.frameCount * 0.01 + this.x * 0.01) * 0.01;
                    }
                }
                
                display() {
                    p.push();
                    p.translate(this.x, this.y);
                    
                    // Draw trunk
                    p.fill(this.hue, this.saturation, this.brightness);
                    p.noStroke();
                    p.rect(-this.width/2, -this.height, this.width, this.height, this.width/2);
                    
                    // Draw branches
                    for (let branch of this.branches) {
                        p.push();
                        p.rotate(branch.angle);
                        p.rect(0, -branch.length/2, branch.width, branch.length, branch.width/2);
                        p.pop();
                    }
                    
                    p.pop();
                }
            }
            
            class Firefly {
                constructor() {
                    this.pos = p.createVector(
                        p.random(p.width),
                        p.random(p.height * 0.2, p.height * 0.8)
                    );
                    this.vel = p.createVector(p.random(-0.5, 0.5), p.random(-0.5, 0.5));
                    this.acc = p.createVector();
                    this.maxSpeed = 2;
                    this.size = p.random(3, 8);
                    this.hue = p.random(50, 70);
                    this.saturation = p.random(80, 100);
                    this.brightness = p.random(80, 100);
                    this.targetBrightness = this.brightness;
                    this.life = p.random(100, 200);
                    this.age = 0;
                    this.glowSize = this.size * 3;
                    this.followFactor = p.random(0.1, 0.3);
                }
                
                update() {
                    this.age++;
                    
                    // Random movement
                    this.acc.add(p.createVector(p.random(-0.1, 0.1), p.random(-0.1, 0.1)));
                    
                    // Follow mouse if it's moving
                    if (mouseInfluence > 0.1 && p.dist(this.pos.x, this.pos.y, p.mouseX, p.mouseY) < 300) {
                        let followForce = p5.Vector.sub(p.createVector(p.mouseX, p.mouseY), this.pos);
                        followForce.mult(this.followFactor * mouseInfluence);
                        this.acc.add(followForce);
                    }
                    
                    // Apply physics
                    this.vel.add(this.acc);
                    this.vel.limit(this.maxSpeed);
                    this.pos.add(this.vel);
                    this.acc.mult(0);
                    
                    // Boundary check
                    if (this.pos.x < 0) this.pos.x = p.width;
                    if (this.pos.x > p.width) this.pos.x = 0;
                    if (this.pos.y < 0) this.pos.y = p.height;
                    if (this.pos.y > p.height) this.pos.y = 0;
                    
                    // Pulsing brightness
                    if (p.random() < 0.05) {
                        this.targetBrightness = p.random(60, 100);
                    }
                    this.brightness = p.lerp(this.brightness, this.targetBrightness, 0.1);
                    
                    // Regenerate if too old
                    if (this.age > this.life) {
                        this.age = 0;
                        this.pos.set(p.random(p.width), p.random(p.height * 0.2, p.height * 0.8));
                    }
                }
                
                display() {
                    // Draw glow
                    p.push();
                    p.blendMode(p.SCREEN);
                    for (let r = this.size; r < this.glowSize; r += 2) {
                        let alpha = p.map(r, this.size, this.glowSize, 0.5, 0);
                        p.fill(this.hue, this.saturation, this.brightness, alpha);
                        p.noStroke();
                        p.ellipse(this.pos.x, this.pos.y, r, r);
                    }
                    p.pop();
                    
                    // Draw firefly
                    p.fill(this.hue, this.saturation, this.brightness);
                    p.noStroke();
                    p.ellipse(this.pos.x, this.pos.y, this.size, this.size);
                }
            }
            
            p.windowResized = function() {
                p.resizeCanvas(p.min(p.windowWidth, 1200), p.windowHeight);
            };
            
            p.mouseMoved = function() {
                // Increase firefly activity when mouse moves
                for (let firefly of fireflies) {
                    if (p.random() < 0.1) {
                        firefly.vel.add(p.createVector(p.random(-1, 1), p.random(-1, 1)));
                    }
                }
            };
        };
        
        new p5(sketch);
    
function touchMoved() {
  // Forward touch events to mouse events
  if (typeof mouseMoved === 'function') {
    mouseMoved();
  }
  return false; // Prevent default
}

function touchStarted() {
  // Forward to mousePressed
  if (typeof mousePressed === 'function') {
    mousePressed();
  }
  return false; // Prevent default
}

function touchEnded() {
  // Forward to mouseReleased
  if (typeof mouseReleased === 'function') {
    mouseReleased();
  }
  return false; // Prevent default
}
  // Fullscreen toggle
  document.getElementById('fs-toggle').addEventListener('click', function() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => {
        console.log('Fullscreen request failed: ', err);
      });
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
  });
  
  // Hide fullscreen button after inactivity
  const fsButton = document.getElementById('fs-toggle');
  let timeout;
  document.addEventListener('mousemove', function() {
    fsButton.style.opacity = '0.3';
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fsButton.style.opacity = '0';
    }, 2000);
  });
  </script>

              
          
                
          
              
